// Generated by dts-bundle-generator v9.5.1

/**
* Represents the type of operation to be performed on the collection.
*/
export enum OpType {
	/**
	* Create operation.
	*/
	CREATE = 0,
	/**
	* Update operation.
	*/
	UPDATE = 1,
	/**
	* Delete operation.
	*/
	DELETE = 2,
	/**
	* Query Operation.
	*/
	QUERY = 3,
	/**
	* Count Operation.
	*/
	COUNT = 4
}
export type Operators = {
	$gte?: number;
	$gt?: number;
	$lt?: number;
	$lte?: number;
};
export type InOperator<T> = {
	$in?: T[];
};
export type OperatorOrType<T> = T extends number ? T | Operators | InOperator<T> : T | InOperator<T>;
export type LogicalOperators<T extends SchemaType> = {
	$and?: Partial<QueryType<T>>[];
	$or?: Partial<QueryType<T>>[];
};
export type QueryType<T extends SchemaType> = Partial<{
	[K in keyof T["properties"]]: OperatorOrType<ExtractType<T["properties"][K]["type"]>>;
}> & LogicalOperators<T> | LogicalOperators<T>[];
export class Query<T extends SchemaType> {
	constructor(query: QueryType<T>, schema: Schema<T>);
	readonly query: QueryType<T>;
}
//test
export type BaseStorageOptions = {
	[name: string]: string | boolean | number;
};
export class BaseStorage<Schemas extends SchemaTypeRecord> extends StorageInternal<Schemas> {
	static create<SchemasCreate extends SchemaTypeRecord>(dbName: string, schemas: SchemasCreate, options?: BaseStorageOptions): Promise<BaseStorage<SchemasCreate>>;
	constructor(dbName: string, schemas: Schemas, options?: BaseStorageOptions);
	readonly dbName: string;
	readonly schemas: Record<keyof Schemas, Schema<Schemas[keyof Schemas]>>;
	readonly options: BaseStorageOptions;
	readonly core: CoreStorage;
	start(): Promise<void>;
	close(): Promise<void>;
	count(colectionName: keyof Schemas, query: QueryType<Schemas[keyof Schemas]>): Promise<number>;
	findDocumentById(collectionName: keyof Schemas, id: string): Promise<Doc<Schemas[keyof Schemas]> | null>;
	find(collectionName: keyof Schemas, query: QueryType<Schemas[keyof Schemas]>): Promise<Doc<Schemas[keyof Schemas]>[]>;
	write(op: Operation<Schemas[keyof Schemas]>): Promise<Doc<Schemas[keyof Schemas]>>;
	getOption(name: string): string | boolean | number | undefined;
	getSchema(name: string): Schema<any>;
}
/**
 * Represents the type definition for a schema.
 */
export type SchemaType = {
	/**
	 * The version of the schema.
	 */
	readonly version: number;
	/**
	 * The primary key of the schema.
	 */
	readonly primaryKey: string;
	/**
	 * The type of the schema.
	 */
	readonly type: string;
	/**
	 * An optional array of required fields.
	 */
	readonly required?: string[];
	/**
	 * An optional array of indexes.
	 */
	readonly indexes?: string[];
	readonly encrypted?: string[];
	/**
	 * The properties defined in the schema.
	 */
	readonly properties: {
		[name: string]: Property;
	};
};
/**
 * Represents a schema, including its definition and related methods.
 *
 * @template T - The schema type.
 */
export class Schema<T extends SchemaType> {
	/**
	 * The schema definition.
	 */
	schema: Schema<T>;
	/**
	 * Creates a new `Schema` instance from the provided definition.
	 *
	 * @template TS - The schema type.
	 * @param {TS} defi, Debugnition - The schema definition.
	 * @returns {Schema<TS>} The created `Schema` instance.
	 */
	static create<TS extends SchemaType>(definition: TS): Schema<TS>;
	/**
	 * The version of the schema.
	 */
	readonly version: number;
	/**
	 * The primary key of the schema.
	 */
	readonly primaryKey: string;
	/**
	 * The type of the schema.
	 */
	readonly type: string;
	/**
	 * An optional array of indexes.
	 */
	readonly indexes?: string[];
	readonly required?: string[];
	readonly encrypted?: string[];
	/**
	 * The properties defined in the schema.
	 */
	readonly properties: {
		[K in keyof T["properties"] as T["properties"][K]["required"] extends false | (T["properties"][K]["default"] extends undefined ? true : false) ? K : never]?: T["properties"][K];
	} & {
		[K in keyof T["properties"] as T["properties"][K]["required"] extends false ? never : K]: T["properties"][K];
	};
	/**
	 * Converts the schema to a JSON representation.
	 *
	 * @returns {SchemaType} The JSON representation of the schema.
	 */
	toJSON(): SchemaType;
}
/**
 * Represents a database containing collections of documents.
 * RIDB extends from this class and is used to expose collections.
 *
 * So if you specify:
 * ```typescript
 * const db = new RIDB(
 *     {
 *         schemas: {
 *             demo: {
 *                 version: 0,
 *                 primaryKey: 'id',
 *                 type: SchemaFieldType.object,
 *                 properties: {
 *                     id: {
 *                         type: SchemaFieldType.string,
 *                         maxLength: 60
 *                     }
 *                 }
 *             }
 *         } as const
 *     }
 * )
 * ```
 *
 * The collection will be available as `db.collections.demo` and all the methods for the collection (find, count, findById, update, create, delete) will be available.
 *
 * @template T - A record of schema types.
 */
export class Database<T extends SchemaTypeRecord> {
	/**
	 * Creates a new `Database` instance with the provided schemas and storage module.
	 *
	 * @template TS - A record of schema types.
	 * @param {TS} schemas - The schemas to use for the collections.
	 * @param migrations
	 * @param plugins
	 * @param options
	 * @param password
	 * @returns {Promise<Database<TS>>} A promise that resolves to the created `Database` instance.
	 */
	static create<TS extends SchemaTypeRecord>(db_name: string, schemas: TS, migrations: MigrationPathsForSchemas<TS> | MigrationPathsForSchema<TS[string]>, plugins: Array<typeof BasePlugin>, options: RIDBModule, password?: string, storage?: BaseStorage<TS>): Promise<Database<TS>>;
	/**
	 * The collections in the database.
	 *
	 * This is a read-only property where the key is the name of the collection and the value is a `Collection` instance.
	 */
	readonly collections: {
		[name in keyof T]: Collection<Schema<T[name]>>;
	};
	readonly started: boolean;
	/**
	 * Starts the database.
	 *
	 * @returns {Promise<void>} A promise that resolves when the database is started.
	 */
	start(): Promise<void>;
	/**
	 * Closes the database.
	 *
	 * @returns {Promise<void>} A promise that resolves when the database is closed.
	 */
	close(): Promise<void>;
}
/**
 * Represents a function type for creating storage with the provided schema type records.
 *
 * @template T - The schema type record.
 * @param {T} records - The schema type records.
 * @returns {Promise<InternalsRecord>} A promise that resolves to the created internals record.
 */
export type CreateStorage = <T extends SchemaTypeRecord>(records: T) => Promise<BaseStorage<T>>;
/**
 * Represents a storage module with a method for creating storage.
 */
export type RIDBModule = {
	/**
	 * Plugin constructors array
	 */
	apply: (plugins: Array<typeof BasePlugin>) => Array<BasePlugin>;
};
/**
 * Represents an operation to be performed on a collection.
 *
 * @template T - The schema type of the collection.
 */
export type Operation<T extends SchemaType> = {
	/**
	 * The name of the collection on which the operation will be performed.
	 */
	collection: string;
	/**
	 * The type of operation to be performed (e.g., CREATE, UPDATE, DELETE).
	 */
	opType: OpType;
	/**
	 * The data involved in the operation, conforming to the schema type.
	 */
	data: Doc<T>;
	/**
	 * An array of indexes related to the operation.
	 */
	indexes: Array<string>;
};
export type Hook = (schema: Schema<SchemaType>, migration: MigrationPathsForSchema<SchemaType>, doc: Doc<SchemaType>) => Doc<SchemaType>;
export type BasePluginOptions = {
	docCreateHook?: Hook;
	docRecoverHook?: Hook;
};
export class BasePlugin implements BasePluginOptions {
	docCreateHook?: Hook;
	docRecoverHook?: Hook;
}
/**
 * Represents a property within a schema, including various constraints and nested properties.
 */
export class Property {
	/**
	 * The type of the property.
	 */
	readonly type: string;
	/**
	 * The version of the property, if applicable.
	 */
	readonly version?: number;
	/**
	 * The primary key of the property, if applicable.
	 */
	readonly primaryKey?: string;
	/**
	 * An optional array of nested properties for array-type properties.
	 */
	readonly items?: Property[];
	/**
	 * The maximum number of items for array-type properties, if applicable.
	 */
	readonly maxItems?: number;
	/**
	 * The minimum number of items for array-type properties, if applicable.
	 */
	readonly minItems?: number;
	/**
	 * The maximum length for string-type properties, if applicable.
	 */
	readonly maxLength?: number;
	/**
	 * The minimum length for string-type properties, if applicable.
	 */
	readonly minLength?: number;
	/**
	 * An optional array of required fields for object-type properties.
	 */
	readonly required?: boolean;
	/**
	 * An optional default value for the property.
	 */
	readonly default?: any;
	/**
	 * An optional map of nested properties for object-type properties.
	 */
	readonly properties?: {
		[name: string]: Property;
	};
}
export type InternalsRecord = {
	[name: string]: BaseStorage<SchemaTypeRecord>;
};
/**
 * ExtractType is a utility type that maps a string representing a basic data type to the actual TypeScript type.
 *
 * @template T - A string literal type representing the basic data type ('string', 'number', 'boolean', 'object', 'array').
 *
 * @example
 * type StringType = ExtractType<'string'>; // StringType is string
 * type NumberType = ExtractType<'number'>; // NumberType is number
 * type BooleanType = ExtractType<'boolean'>; // BooleanType is boolean
 * type ObjectType = ExtractType<'object'>; // ObjectType is object
 * type ArrayType = ExtractType<'array'>; // ArrayType is Array<any>
 */
export type ExtractType<T extends string> = T extends "string" ? string : T extends "number" ? number : T extends "boolean" ? boolean : T extends "object" ? object : T extends "array" ? Array<any> : never;
/**
 * Doc is a utility type that transforms a schema type into a document type where each property is mapped to its extracted type.
 *
 * @template T - A schema type with a 'properties' field where each property's type is represented as a string.
 *
 * type Document = Doc<Schema>; // Document is { name: string; age: number; }
 */
export type Doc<T extends SchemaType> = {
	[K in keyof T["properties"] as T["properties"][K]["required"] extends false | (T["properties"][K]["default"] extends undefined ? true : false) ? K : never]?: ExtractType<T["properties"][K]["type"]>;
} & {
	[K in keyof T["properties"] as T["properties"][K]["required"] extends false ? never : K]: ExtractType<T["properties"][K]["type"]>;
} & {
	__version?: number;
};
/**
 * Collection is a class that represents a collection of documents in a database.
 * @template T - A schema type defining the structure of the documents in the collection.
 */
export class Collection<T extends SchemaType> {
	/**
	 * Finds all documents in the collection.
	 *
	 * @returns A promise that resolves to an array of documents.
	 */
	find(query: QueryType<T>): Promise<Doc<T>[]>;
	/**
	 * count all documents in the collection.
	 *
	 * @returns A promise that resolves to an array of documents.
	 */
	count(query: QueryType<T>): Promise<number>;
	/**
	 * Finds a single document in the collection by its ID.
	 *
	 * @param id - The ID of the document to find.
	 * @returns A promise that resolves to the found document.
	 */
	findById(id: string): Promise<Doc<T>>;
	/**
	 * Updates a document in the collection by its ID.
	 *
	 * @param id - The ID of the document to update.
	 * @param document - A partial document containing the fields to update.
	 * @returns A promise that resolves when the update is complete.
	 */
	update(document: Partial<Doc<T>>): Promise<void>;
	/**
	 * Creates a new document in the collection.
	 *
	 * @param document - The document to create.
	 * @returns A promise that resolves to the created document.
	 */
	create(document: Doc<T>): Promise<Doc<T>>;
	/**
	 * Deletes a document in the collection by its ID.
	 *
	 * @param id - The ID of the document to delete.
	 * @returns A promise that resolves when the deletion is complete.
	 */
	delete(id: string): Promise<void>;
}
/**
 * Represents a record of schema types, where each key is a string and the value is a `SchemaType`.
 */
export type SchemaTypeRecord = {
	[name: string]: SchemaType;
};
export abstract class StorageInternal<Schemas extends SchemaTypeRecord> {
	constructor(name: string, schemas: Schemas);
	abstract start(): Promise<void>;
	abstract close(): Promise<void>;
	abstract count(colectionName: keyof Schemas, query: QueryType<Schemas[keyof Schemas]>): Promise<number>;
	abstract findDocumentById(collectionName: keyof Schemas, id: string): Promise<Doc<Schemas[keyof Schemas]> | null>;
	abstract find(collectionName: keyof Schemas, query: QueryType<Schemas[keyof Schemas]>): Promise<Doc<Schemas[keyof Schemas]>[]>;
	abstract write(op: Operation<Schemas[keyof Schemas]>): Promise<Doc<Schemas[keyof Schemas]>>;
}
declare class CoreStorage {
	/**
	* @param {any} document
	* @param {Query} query
	* @returns {boolean}
	*/
	matchesQuery(document: any, query: Query<any>): boolean;
}
export type EnumerateUpTo<N extends number, Acc extends number[] = [
]> = Acc["length"] extends N ? Acc[number] : EnumerateUpTo<N, [
	...Acc,
	Acc["length"]
]>;
export type EnumerateFrom1To<N extends number> = Exclude<EnumerateUpTo<N>, 0> | (N extends 0 ? never : N);
export type IsVersionGreaterThan0<V extends number> = V extends 0 ? false : true;
export type AnyVersionGreaterThan1<T extends Record<string, SchemaType>> = true extends {
	[K in keyof T]: IsVersionGreaterThan0<T[K]["version"]>;
}[keyof T] ? true : false;
export type MigrationFunction<T extends SchemaType> = (doc: Doc<T>) => Doc<T>;
export type MigrationPathsForSchema<T extends SchemaType> = T["version"] extends 0 ? {} : {
	[K in EnumerateFrom1To<T["version"]>]: MigrationFunction<T>;
};
export type MigrationPathsForSchemas<T extends SchemaTypeRecord> = {
	[K in keyof T]: MigrationPathsForSchema<T[K]>;
};
export type MigrationsParameter<T extends SchemaTypeRecord> = AnyVersionGreaterThan1<T> extends true ? {
	migrations: MigrationPathsForSchemas<T>;
} : {
	migrations?: never;
};
/**
 * Represents a RIDB (Rust IndexedDB) instance.
 * This is the main class exposed by the RIDB Storage sdk and is used to create a database instance.
 *
 * ### Usage:
 *
 * ```typescript
 * const db = new RIDB(
 *     {
 *         schemas: {
 *             demo: {
 *                 version: 0,
 *                 primaryKey: 'id',
 *                 type: SchemaFieldType.object,
 *                 properties: {
 *                     id: {
 *                         type: SchemaFieldType.string,
 *                         maxLength: 60
 *                     }
 *                 }
 *             }
 *         } as const
 *     }
 * )
 * ```
 *
 * ### Starting the database
 * ```typescript
 * await db.start({dbName: "demo"})
 * ```
 *
 * ### Using with encryption plugin
 * You can also optionally specify storageType with a compatible storage of your choice and an optional password to enable encryption plugin
 * ```typescript
 * await db.start({
 *     password: "my-password"
 *     db
 * })
 * ```
 *
 * A compatible storage should be a class implementing [StorageInternal<RIDBTypes.SchemaType> ](../docs/namespaces/RIDBTypes/classes/StorageInternal.md) and its methods.
 *
 * ### Using with migration plugin
 * The migration plugin will automatically migrate your documents for you as you upgrade and change your schemas over the time.
 *
 * ```typescript
 * const db = new RIDB(
 *     {
 *         schemas: {
 *             demo: {
 *                 version: 1,
 *                 primaryKey: 'id',
 *                 type: SchemaFieldType.object,
 *                 required:['id', 'age'],
 *                 properties: {
 *                     id: {
 *                         type: SchemaFieldType.string,
 *                         maxLength: 60
 *                     },
 *                     age: {
 *                         type: SchemaFieldType.number,
 *                     }
 *                 }
 *             }
 *         } as const,
 *         migrations: {
 *             demo: {
 *                 1: function (doc) {
 *                     return doc
 *                 }
 *             }
 *         }
 *     }
 * )
 *
 * await db.start({dbName: "demo"})
 * ```
 *
 * @class
 * @template T - The type of the schema record.
 */
export type StorageClass<T extends SchemaTypeRecord> = {
	create: (name: string, schemas: T, options: any) => Promise<BaseStorage<T>>;
};
export declare enum StorageType {
	InMemory = "InMemory",
	IndexDB = "IndexDB"
}
export type StartOptions<T extends SchemaTypeRecord> = {
	storageType?: StorageClass<T> | StorageType;
	password?: string;
	[name: string]: any;
};
export declare class RIDB<T extends SchemaTypeRecord = SchemaTypeRecord> {
	private schemas;
	private migrations;
	private plugins;
	private _db;
	private dbName;
	/**
	 * Creates an instance of RIDB.
	 * @param options
	 */
	constructor(options: {
		dbName: string;
		schemas: T;
		plugins?: Array<typeof BasePlugin>;
	} & MigrationsParameter<T>);
	private getStorageType;
	/**
	 * Gets the database instance. Throws an error if the database has not been started.
	 * @throws Will throw an error if the database is not started.
	 * @private
	 */
	private get db();
	get started(): boolean;
	/**
	 * Gets the collections from the database.
	 * @returns The collections object.
	 */
	get collections(): {
		[name in keyof T]: Collection<Schema<T[name]>>;
	};
	/**
	 * Loads the RIDB Rust module.
	 * @returns {Promise<typeof import("@trust0/ridb-wasm")>} A promise that resolves to the RIDB Rust module.
	 * @private
	 */
	static load(): Promise<typeof import("@trust0/ridb-wasm")>;
	/**
	 * Starts the database.
	 * @returns {Promise<RIDBTypes.Database<T>>} A promise that resolves to the database instance.
	 * @param options
	 */
	start(options?: StartOptions<T>): Promise<Database<T>>;
	close(): Promise<void>;
}
/**
 * An enumeration of schema field types.
 */
export declare const SchemaFieldType: {
	string: "string";
	number: "number";
	boolean: "boolean";
	array: "array";
	object: "object";
};

export {};
